{
  "name": "Krt",
  "tagline": "Simple, console-based Python debugger.",
  "body": "# KRT\r\n\r\n### __Simple, small, interactive, console-based Python debugger.__\r\n - Cross-platform\r\n - Django compatibile\r\n\r\n<br>\r\n\r\n__KRT__ inherits from basic python debugger (called `bdb`). The main reason behind development of package was need of user interface during python script debugging in console (or when graphical interface is not available). Although `pdb` have the same (and propbably much more) functionality, I found it not so \"user friendly\".\r\n\r\n<br>\r\n\r\n###__Installation__\r\n\r\nInstall using `pip`.\r\n\r\n```code\r\npip install krt\r\n```\r\n\r\n<br>\r\n\r\n##__Basic script debugging__\r\n```code\r\npython krt.py script.py\r\n# or\r\npython -m krt script.py\r\n```\r\n \r\n <br>\r\n \r\n###__Initializing debugger during program execution__\r\n\r\nThis method of initialization allows initialization at specific line.\r\n\r\n```python\r\nimport krt\r\n\r\ndef func(_something, _nothing):\r\n  local_var = [1, 2, 3, 4]\r\n  # now, initialize krt\r\n  krt.trace()                   \r\n  anything = _somethins + _nothing\r\n  return anything\r\n```\r\n\r\n<br>\r\n\r\nInitializing __krt__ via __@decorator__. This method will initialize __krt__ at 1st line of decorated method or function.\r\n\r\n```python\r\nimport krt\r\n\r\n# initialize krt\r\n@krt.debug()\r\ndef func(_something, _nothing):\r\n  local_var = [1, 2, 3, 4]\r\n  anything = _somethins + _nothing\r\n  return anything\r\n```\r\n\r\n<br>\r\n\r\n##__Django usage__\r\n\r\nOne can use methods mentioned above, but method below allows __krt__ triggering only if run with pre-defined django command.\r\n\r\n##### Setting up django command\r\n1. Inside django applicaiton directory, create directory called `management`, inside which create directory `commands`.\r\n   Following path, must exists `django_project/application/management/commands/`.\r\n2. Create `__init__.py` inside `management` and `commands` directories.\r\n3. Inside directory `commands`, create file `<command>.py`, where `<command>` will be used with `manage.py`.\r\n   Let's say that we've used `krt_runserver.py`.\r\n4. Insert into created file:\r\n```python\r\n from django.core.management.base import BaseCommand\r\n from django.core.management.commands import runserver\r\n\r\n class Command(runserver.Command):\r\n     help = \"Sets trigger for krt decorators\"\r\n\r\n     def __init__(self, *args, **kwargs):\r\n         from django.conf import settings\r\n         setattr(settings, 'krt_django_decorator_trigger_flag', True)\r\n         super(Command, self).__init__(*args, **kwargs)\r\n```\r\n<br>\r\n\r\n##### Use decorator inside view\r\n\r\nDecorator, when used in django project, requires setting of keyword argument `django` to `True`. If the `django` argument is omitted, the debugger will be __always initialized__!\r\n\r\n```python\r\n from django.http import HttpResponse\r\n from  krttest.krt import debug\r\n\r\n @debug(django=True)\r\n def index(request):\r\n     return HttpResponse(\"I'm ok.\")\r\n```\r\n<br>\r\n\r\nNow, when the django server is run with created command, __KRT__ debugger is being initialized on 1st line of view, otherwise the decorators are being ignored.\r\n```code\r\npython ./manage.py krt_runserver\r\n```\r\n<br>\r\n\r\n__Key controls and commands__\r\n```text\r\n  [ ]next (enter pressed)    Evaluate current line and go to next line.\r\n  [s]tep-in                  Step inside if callable, else go to next line.\r\n  [r]eturn                   Return from call to outer frame.\r\n\r\n  [j]ump [<file>] ['disp'] <line> <verbose>\r\n\r\n                             Jump to line in current file. Setting verbose to True or 1\r\n                             will perform jump in 'visible' mode. This mode can take\r\n                             certain amount of time to complete. Consider turning off\r\n                             code display.\r\n\r\n                             When 'disp' is stated, the number refers to dispatch number,\r\n                             counted from beginning of program evaluation. Using dispatch\r\n                             jumping in combination with line jumping will NOT work.\r\n\r\n                             Use '.' as reference to currently debugged file.\r\n\r\n                             Examples:\r\n                                 $ jump . 20\r\n                                 $ jump disp 3000 True\r\n                                 $ jump 20\r\n                                 $ jump disp 300\r\n\r\n  [c]ontinue                 Continue evaluation of file.\r\n  [w]atch <variable>         Add local 'variable' to watches.\r\n  [u]n-watch <variable>      Remove local 'variable' from watches.\r\n  [o]utput                   Show / hide output of debugged program (replaces whole ui).\r\n  [v]ars                     Show / hide local variables.\r\n  [st]ack                    Show / hide current stack of stack frames.\r\n  [co]de                     Show / hide code display.\r\n  [re]size                   Adjust number of lines of code display.\r\n  [h]elp                     Display small / large help panel.\r\n  [q]uit                     Leave debugger.\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}